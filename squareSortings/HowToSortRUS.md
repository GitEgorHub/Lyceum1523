# Простейшие алгоритмы сортировки

## Исходная постановка задачи

- Задан массив a из n элементов. Все элементы массива являются целыми числами. Необходимо отсортировать массив по возрастанию, то есть переупорядочить его элементы так, чтобы за элементами 
с меньшими значениями шли элементы с большими значениями.

- Ограничения задачи: $1 \le n \le 1000, |a_i| \le 1000000000$

## Сортировка пузырьком

Алгоритм заключается в следующем: 

- пройдёмся по массиву и поменяем местами те соседние элементы, которые идут в <<неправильном>> порядке, то есть те, для которых $a_i > a_{i + 1}$.

- будем повторять эту операцию до тех пор, пока массив не будет отсортирован.

### Пример сортировки:

4 98 23 12 68

1 шаг:  4 23 12 68 98

2 шаг: 4 12 23 68 98

3 шаг: ничего не меняется, убеждаемся, что массив отсортирован.

### За сколько работает? 

Нетрудно заметить, что мы можем использовать не более $n$ итераций нашего алгоритма для того, что отсортировать массив. Тогда, учитывая, что внутренний цикл делает $n - 1$ итерацию, то получим, что в худшем случае алгоритм выполнит $n \cdot (n - 1)$ итерацию, что эквивалентно $O(n^2)$

## Сортировка выбором

- пройдёмся циклом, на каждой итерации $i$ которого мы будем ставить $i$-й элемент на своё место.

- как поставить $i$-й элемент на своё место? Первые $i - 1$ элементов мы уже поставили, поэтому наша идея заключается в том, чтобы найти минимальный элемент среди оставшихся и поставить его на место $i$.

### Пример сортировки:

4 98 23 12 68

1 шаг: 4 98 23 12 68

2 шаг: 4 12 98 23 68

3 шаг: 4 12 23 98 68

4 шаг: 4 12 23 68 98

### За сколько работает?

Всего надо поставить $n$ эементов на своё место. Сколько итераций делает внутренний цикл? Для каждого перебираемого во внешнем цикле элемента мы будем проходиться циклом по всем возможным кандидатам, то есть мы будем проходиться суммарно 

$$(n - 1) + (n - 2) + ... + 1 = \frac{n \cdot (n - 1)}{2}$$ 

Что даёт нам асимтотику $O(n^2)$
