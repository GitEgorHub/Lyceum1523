# Простейшие алгоритмы сортировки

## Исходная постановка задачи

- Задан массив a из n элементов. Все элементы массива являются целыми числами. Необходимо отсортировать массив по возрастанию, то есть переупорядочить его элементы так, чтобы за элементами 
с меньшими значениями шли элементы с большими значениями.

- Ограничения задачи: $1 \le n \le 1000, |a_i| \le 1000000000$

## Сортировка пузырьком

Алгоритм заключается в следующем: 

- пройдёмся по массиву и поменяем местами те соседние элементы, которые идут в <<неправильном>> порядке, то есть те, для которых $a_i > a_{i + 1}$.

- будем повторять эту операцию до тех пор, пока массив не будет отсортирован.

### Пример сортировки:

4 98 23 12 68

1 шаг:  4 23 12 68 98

2 шаг: 4 12 23 68 98

3 шаг: ничего не меняется, убеждаемся, что массив отсортирован.

### За сколько работает? 

Нетрудно заметить, что мы можем использовать не более $n$ итераций нашего алгоритма для того, что отсортировать массив. Тогда, учитывая, что внутренний цикл делает $n - 1$ итерацию, то получим, что в худшем случае алгоритм выполнит $n \cdot (n - 1)$ итерацию, что эквивалентно $O(n^2)$

## Сортировка выбором

- пройдёмся циклом, на каждой итерации $i$ которого мы будем ставить $i$-й элемент на своё место.

- как поставить $i$-й элемент на своё место? Первые $i - 1$ элементов мы уже поставили, поэтому наша идея заключается в том, чтобы найти минимальный элемент среди оставшихся и поставить его на место $i$.

### Пример сортировки:

4 98 23 12 68

1 шаг: 4 98 23 12 68

2 шаг: 4 12 98 23 68

3 шаг: 4 12 23 98 68

4 шаг: 4 12 23 68 98

### За сколько работает?

Всего надо поставить $n$ элементов на своё место. Сколько итераций делает внутренний цикл? Для каждого перебираемого во внешнем цикле элемента мы будем проходиться циклом по всем возможным кандидатам, то есть мы будем проходиться суммарно 

$$(n - 1) + (n - 2) + ... + 1 = \frac{n \cdot (n - 1)}{2}$$ 

Что даёт нам сложность алгоритма $O(n^2)$

## Сортировка вставками

- Создадим массив, в котором после завершения алгоритма будет лежать ответ. Будем поочередно вставлять элементы из исходного массива так, чтобы элементы в массиве-ответе всегда были отсортированы. 

- Реализовывать алгоритм удобнее по-другому (создавать новый массив и реально что-то вставлять в него относительно сложно): просто сделаем так, чтобы отсортирован был некоторый префикс исходного массива, вместо вставки будем менять текущий элемент с предыдущим, пока они стоят в неправильном порядке.

### Пример сортировки:

4 98 23 12 68

1 шаг: 4 98 23 12 68

2 шаг: 4 12 98 23 68

3 шаг: 4 12 23 98 68

4 шаг: 4 12 23 68 98

### За сколько работает?

Аналогично предыдущему пункту. Сложность алгоритма $O(n^2)$

## Сортировка подсчётом

- давайте для каждого числа посчитаем, сколько раз оно встречается в массиве.

- далее для сортировки просто пройдёмся по всем числам от минимального элемента в массиве до максимального и добавим их столько раз, сколько они встречались в массиве. 

-  массив будет отсортирован просто потому, что мы перебираем все возможные элементы от минимального до максимального.

### Пример сортировки

4 2 1 3 3 3 -1 4

-1 1 раз
0 0 раз
1 1 раз
2 1 раз
3 3 раза
4 2 раза

-1 1 2 3 3 3 4 4

### За сколько работает? 

Так как мы перебираем все числа от минимума до максимума, то количество операций это $2 * A$, где $A$ - максимально допустимый элемент массива.

Также в массиве $n$ чисел, по которым надо проходиться, то количество операций увеличивается на $C * n$, где $C$ - константа.

Сложность алгоритма $O(A + n)$
