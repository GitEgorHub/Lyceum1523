# Строки

### Что такое строковый тип?

На предыдущих занятиях мы уже ознакомились с массивами. Как мы поняли, массив --- набор элементов. Сегодня мы научимся пользоваться частным случаем массивов для работы с символами --- строками. 

Строка в основном своём смысле --- массив из нескольких символов (`char`). В С++ её реализация очень напоминает `std::vector`.

Чтобы начать пользоваться строками, необходимо подключить следующую библиотеку и пространство имён:
```
#include<string>

using namespace std;
```

Пример создания строки:

```
string s = "abacaba";
```

Мы видим, что строка описывается так же, как и обычные переменные, а, если мы хотим присвоить ей конкретный набор символов, то можем просто заключить значение этой строки в двойные кавычки.

У строк есть много интересных функций:

- размер строки: `s.size()`

Пример: для строки "abacaba" эта функция вернёт 7, так как количество символов в строке равно 7

Асимптотика --- $O(1)$

- переворот строки: `reverse(s.begin(), s.end())` 

Например после применения этой операции к строке s равной "acacac" получится строка "cacaca". Эта операция работает с итераторами, то есть, грубо говоря, индексаторами этой строки. Мы возьмём строку, начиная с `s.begin()` и заканчивая `s.end()` и перевернём эту часть. Из этого мы понимаем, что переворачивать мы можем не всю строку, а только часть, если нам это нужно.

Асимптотика алгоритма --- $O(|s|)$. Здесь и далее $|s|$ обозначает длину строки $s$.

---

- сортировка строки: `sort(s.begin(), s.end())`

Сортрует все символы строки в лексикографическом порядке. Например, после применения к строке "azachem" мы получим строку "aacehmz".

Что такое лексикографический порядок? 

Давайте сначала узнаем, что такое лексикографическое сравнение. Например, нам надо сравнить две строки: $s$ и $t$. Тогда, чтобы понять, какая из них меньше, мы будем сравнивать поочерёдно первый, затем второй, затем третий и так далее символы соответственно. Если в каком-то месте символ в $s$ меньше символа в $t$, то тогда $s < t$. Если то же самое, но символ в $s$ больше соответствующего в $t$, то $s > t$. Если же все символы совпадают, то меньше та строка, у которой меньше длина. Если же и длины равны, то строки равны. 

Поэтому лексикографический порядок ещё называют алфавитным порядком. То есть для сортировки мы просто поставим сначала буквы, которые идут раньше, потом те, что идут позже.

Асимптотика алгоритма --- $O(|s| \log |s|)$

---

- получение подстроки: `s.substr(x, y)`

При применении к строке s, равной "acacac" операции `s.substr(2, 2)` мы получим строку "ac", т.е. substr берёт подстроку, начиная ы элемента $x$ длины $y$.

Асимптотика алгоритма --- $O(|s|)$

---

- чтение строки с пробелами `getline(cin, s)`

Если мы просто напишем `cin >> s`, как мы делаем всегда, то строка прочитается до пробела. В случае же с getline строка прочитается с пробелами.

---

Также есть несколько полезных функций для символов (`char`):

- Приведение $c$ к верхнему регистру --- `toupper(c)`
- Приведение $c$ к нижнему регистру --- `tolower(c)`
- Проверка на то, является ли $c$ латинской буквой --- `isalpha(c)`
- Проверка на то, является ли $c$ цифрой --- `isdigit(c)`
- Проверка на то, находится ли $c$ в верхнем регистре --- `isupper(c)`
- Проверка на то, находится ли $c$ в нижнем регистре --- `islower(c)`

## Видео по строкам:

[![Watch the video](https://ciksiti.com/f/5b696c159080a6ee6f529e8812c23cfc.png)](https://www.youtube.com/watch?v=Sdk3ziwZZyk&t=3s)
